Crasm 1.8:                         Intclock                                                                          page  1

                         1          NAM Intclock
                         2          PAGE 66,132
                         3  
                         4  ;      Interrupt-Driven Clock Example
                         5  
                         6  ; This program implements an interrupt-driven clock program. It uses
                         7  ; the NMI interrupt connected to the LINE signal to count time. This
                         8  ; makes it much more accurate than a timing delay loop (like Example
                         9  ; 6), as the line frequency is very accurate over long periods of
                        10  ; time. In order for this to work you need to connect a jumper wire
                        11  ; from the LINE signal to the NMI* signal. The causes an interrupt to
                        12  ; occur every 60th of a second. Note that we could use the 1Hz signal,
                        13  ; but it is driven by an RC oscillator which is not very stable or
                        14  ; accurate.
                        15  
                        16  ; Set the initial time by writing the current hours, minutes, and
                        17  ; seconds (in BCD) to addresses $0000, $0001, $0002 repectively. Then
                        18  ; run from address $004. Don't connect the jumper wire until you have
                        19  ; entered the program.
                        20  
                        21  ; Written by Jeff Tranter <tranter@pobox.com>
                        22  
                        23          CPU 6800
                        24  
  FCBC                  25          REDIS   EQU $FCBC
  FD7B                  26          DSPLAY  EQU $FD7B
                        27  
                        28  ; Set this to one this if you want a 24-hour clock (0-24 hours).
                        29  ; Leave it set to zero for 12-hour time (1-12).
  0000                  30          TWENTYFOURHOUR = 0
                        31  
  0000                  32          * = $0000
                        33  
0000 00                 34  HOUR    DS      1       ; Hour (1-12) in BCD (0-23 in 24-hour mode)
0001 00                 35  MINUTE  DS      1       ; Minute (0-59) in BCD
0002 00                 36  SECOND  DS      1       ; Second (0-59) in BCD
0003 00                 37  JIFFY   DS      1       ; 60ths of a second (in BCD)
                        38  
                        39  ; Main program. Simply displays the hours, minutes and seconds that
                        40  ; are updated by the interrupt handler routine.
                        41  
                        42  ; TODO: Prompt user to enter the current time on startup.
                        43  
0004 BDFCBC             44  START   JSR    REDIS   ; Reset display address
0007 C603               45          LDAB   #3      ; Number of bytes to display
0009 CE0000             46          LDX    #HOUR   ; Address of bytes to output
000C 9602               47          LDAA   SECOND  ; Get current seconds
000E 36                 48          PSHA           ; Save it on stack
000F BDFD7B             49          JSR    DSPLAY  ; Display time
0012 32                 50          PULA           ; Restore seconds
                        51  
                        52  ; Wait for seconds to change before updating display again.
                        53  
0013 9102               54  WAIT    CMPA   SECOND  ; Did seconds change from last value?
0015 27FC               55          BEQ    WAIT    ; If not, keep waiting
0017 20EB               56          BRA    START   ; Repeat forever
                        57  
                        58  ; NMI Interrupt handler routine. Called 60 times per second. It
                        59  ; increments the jiffies, seconds, minutes, and hours, clearing and
                        60  ; rolling over as needed.
                        61  
0019 9603               62  INT     LDAA    JIFFY   ; Get 60ths of a second


Crasm 1.8:                         Intclock                                                                          page  2

001B 8B01               63          ADDA    #1      ; Add one
001D 19                 64          DAA             ; Convert to BCD
001E 9703               65          STAA    JIFFY   ; Save it
0020 8160               66          CMPA    #$60    ; Did we reach 60?
0022 2D2E               67          BLT     RET     ; No, then done
0024 7F0003             68          CLR     JIFFY   ; Set jiffies to zero
0027 9602               69          LDAA    SECOND  ; Get Seconds
0029 8B01               70          ADDA    #1      ; Add one
002B 19                 71          DAA             ; Convert to BCD
002C 9702               72          STAA    SECOND  ; Save it
002E 8160               73          CMPA    #$60    ; Did we reach 60?
0030 2D20               74          BLT     RET     ; No, then done
0032 7F0002             75          CLR     SECOND  ; Set seconds to zero
0035 9601               76          LDAA    MINUTE  ; Get minutes
0037 8B01               77          ADDA    #1      ; Add one
0039 19                 78          DAA             ; Convert to BCD
003A 9701               79          STAA    MINUTE  ; Save it
003C 8160               80          CMPA    #$60    ; Did we reach 60?
003E 2D12               81          BLT     RET     ; No, then done
0040 7F0001             82          CLR     MINUTE  ; Set minutes to zero
0043 9600               83          LDAA    HOUR    ; Get hours
0045 8B01               84          ADDA    #1      ; Add one
0047 19                 85          DAA             ; Convert to BCD
0048 9700               86          STAA    HOUR    ; Save it
                        87          if TWENTYFOURHOUR
                         C          CMPA    #$24    ; Did we reach 24?
                        89          else
004A 8113               90          CMPA    #$13    ; Did we reach 13?
                        91          endc
004C 2D04               92          BLT     RET     ; No, then done
                        93          if TWENTYFOURHOUR
                         C          LDAA    #0      ; Reset hour to 0
                        95          else
004E 8601               96          LDAA    #1      ; Reset hour to 1
                        97          endc
0050 9700               98          STAA    HOUR    ; Save it
0052 3B                 99  RET     RTI             ; Return from interrupt
                       100  
                       101  ; Note that in the Monitor ROM the NMI vector at $FFFC,D points to
                       102  ; $00FD, which is in RAM. We add a jump there to the interrupt
                       103  ; handler.
                       104  
  00FD                 105          * = $00FD       ; Address of NMI handler
00FD 7E0019            106          JMP INT         ; Call interrupt handler
                       107  

ERRORS:       0
WARNINGS:     0

Successful assembly...
 Last address       ff (255)
 Code length        ac (172)












Crasm 1.8:                         Intclock                                                                          page  3

 FD7B   Abs DSPLAY                                            0000   Abs HOUR                                             
 0019   Abs INT                                               0003   Abs JIFFY                                            
 0001   Abs MINUTE                                            FCBC   Abs REDIS                                            
^0052   Abs RET                                               0002   Abs SECOND                                           
 0004   Abs START                                             0000   Abs TWENTYFOURHOUR                                   
 0013   Abs WAIT                                             


























































